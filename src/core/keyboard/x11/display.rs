use crate::core::keyboard::x11::context::XRecordContext;
use crate::core::keyboard::x11::record::range::XRecordRange;
use std::ffi::{CStr, c_int};
use std::ops::Deref;
use std::ptr::{NonNull, null};
use x11::xlib::{self, Display, XExtCodes};
use x11::xrecord::{self, XRecordClientSpec};

#[repr(transparent)]
pub struct XDisplay(NonNull<Display>);

impl XDisplay {
	#[inline]
	pub fn from_raw(raw_ptr: *mut Display) -> Option<Self> {
		NonNull::new(raw_ptr).map(Self)
	}

	pub fn new() -> Option<Self> {
		Self::from_raw(unsafe { xlib::XOpenDisplay(null()) })
	}

	#[inline]
	pub const fn as_ptr(&self) -> *mut Display {
		self.0.as_ptr()
	}

	/// The XSync function flushes the output buffer and then waits until all
	/// requests have been received and processed by the X server. Any errors generated
	/// must be handled by the error handler. For each protocol error received by Xlib,
	/// XSync calls the client application's error handling routine.
	/// Any events generated by the server are enqueued into the library's event queue.
	///
	/// Finally, if you passed False, XSync does not discard the events in the queue.
	/// If you passed True, XSync discards all events in the queue, including those
	/// events that were on the queue before XSync was called. Client applications
	/// seldom need to call XSync.
	#[inline]
	pub fn sync(&mut self, discard_events: bool) {
		unsafe {
			xlib::XSync(self.as_ptr(), discard_events as _);
		}
	}

	/// The XPending function returns the number of events that have been received from
	/// the X server but have not been removed from the event queue.
	#[inline]
	pub fn pending(&mut self) -> i32 {
		unsafe { xlib::XPending(self.as_ptr()) }
	}

	/// The XinitExtension extension function determines if the extension exists.
	/// Then, it allocates storage for maintaining the information about the extension
	/// on the connection, chains this onto the extension list for the connection,
	/// and returns the information the stub implementor needs to access the extension.
	///
	///The extension number in the XExtCodes data structure is needed in the other calls that follow. This extension number is unique only to a single connection.
	pub fn init_exeption<'name>(
		&mut self,
		name: &'name CStr,
	) -> Result<NonNull<XExtCodes>, &'name CStr> {
		let xinitext = unsafe { xlib::XInitExtension(self.as_ptr(), name.as_ptr()) };

		NonNull::new(xinitext).ok_or(name)
	}

	/// Return a connection number for the specified display.
	/// On a POSIX-conformant system, this is the file descriptor of the connection.
	#[inline]
	pub fn get_connection_number(&self) -> i32 {
		unsafe { xlib::XConnectionNumber(self.as_ptr()) }
	}

	pub fn new_context(
		&mut self,
		datum_flags: c_int,
		clients: &mut [XRecordClientSpec],
		ranges: &mut [XRecordRange],
	) -> Result<XRecordContext, ErrCreateContext> {
		let result = unsafe {
			xrecord::XRecordCreateContext(
				self.as_ptr(),
				datum_flags,
				clients.as_ptr() as *mut u64,
				clients.len() as _,
				ranges.as_ptr() as *mut *mut x11::xrecord::XRecordRange,
				ranges.len() as _,
			)
		};
		#[allow(dropping_references)]
		drop(ranges);

		match result {
			0 => Err(ErrCreateContext::Failed),
			a if a == x11::xlib::BadIDChoice as u64 => Err(ErrCreateContext::BadIDChoice),
			a if a == x11::xlib::BadMatch as u64 => Err(ErrCreateContext::BadMatch),
			a if a == x11::xlib::BadValue as u64 => Err(ErrCreateContext::BadValue),
			result => Ok(unsafe { XRecordContext::from_raw(self, result) }),
		}
	}
}

impl Deref for XDisplay {
	type Target = Display;

	#[inline]
	fn deref(&self) -> &Self::Target {
		unsafe { self.0.as_ref() }
	}
}

impl Drop for XDisplay {
	#[inline]
	fn drop(&mut self) {
		unsafe { xlib::XCloseDisplay(self.as_ptr()) };
	}
}

pub enum ErrCreateContext {
	Failed,
	BadIDChoice,
	BadMatch,
	BadValue,
}
